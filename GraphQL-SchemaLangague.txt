.....................................................................................
	GraphQL - Server Side : GraphQL Schema language spec and implementation
...................................................................................

How to build rest applications?

 Restfull web services are built based on "resources" in the problem domain.

Resource represents a Object which expose data 


eg: CustomerResource,OrderResource,ProductResource
Resources are identified by URL /api/customers and Method "GET | POST | PUT |DELETE "
	
How to build graphql applications?
 
Graphql apps are built based on Objects called "Models".

What ever lanaugage we have to think in terms of Objects.

Object shape is described by "schema".

Schema is nothing but plan /design.

Schema represents the Object design

In Graphql The design is represented by "GraphQL schema Lanaguage"
.....................................................................................
			  SDL - Schema definition language
.....................................................................................

SDL Core concepts:

1.Type System:
   The Type system defines the Platform indenpendent data types and variable which describe what data can be queired by client.


query getUserData {
 
   user {
	name             =>SDL=>|SDL|===>Enity==>Biz logic(Services)====>DataSources
   }

}

Both Servers and clients talks via common language called SDL...

SDL provides language independant abstraction
				 
				|---- Java/Kotlin/scala --Jvm
			SDL-----|-----js/ts ----node



syntax:

type TypeName {
   field:DataType
}
In SDL , there is root type , every type is dervied from the root type

type schema{
  query:Query
  mutation:Mutation
  subscription:Subscription
}

type Query {
  #apis
}

type Mutation { 
 #apis
}

type Subscription{
 #apis
}

Query:
.....
Server side 

type Query {
  #apis
  greet:String
  user:User
  user(id:Int):User
}

Client Side
query {
 #api- sending request for invocation at server
  greet
}

query {
 #api
 user {
   id
   name
 }
}
query {
 #api
 user(id:1) {
   id
   name
 }
}
...
Server side
type Mutation { 
 #apis
 createUser(user:User):User
}

ClientSide:

mutation CreateUser($user:User){
  
   createUser(user:$user){
     id
     name
   }
}
SDL Defines its language and platform independant data types:
.............................................................
1.Scallar types
2.Custom Types/ReferenceTypes/Object Types


1.Scallar Types:
  Scallars are like primitive types in your language

1.Int -32 bit signed integer
2.String - UTF-8 char Sequence
3.Boolean - true or false
4.Float - singed double 
5.ID (Serialized String)- A unique identifier

2.Object Type/Complex/User Defined/Reference Type
 Similar to classes in object oriented languages- like java,C#

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean  
}


Object Type can have other Object Type :
  Like has a relationship/ Dependency injection

type Address {
  city:String
  state:String
  zipcode:String
}

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:Address
}

type Query{ 
  user:User
}

Client side
query getUser{
  user {
   id
   firstName
   address {
     city
   } 
  }
}
....................................**********......................................
....................................................................................
			  Handling null and not null values
...................................................................................

Client Query With data
{
  name  --------> response {name:"subramanian"}
}

Client Query Without data
{
  name  --------> response {name:null}
}

I dont want null value for a given field? How to force the field must have data or must not have null?
 => not null fields

syntax:
 fieldName:Type!
!(not null)

type Address {
  city:String
  state:String
  zipcode:String
}


type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:Address
}
.....................................................................................
				...................................................................................
			  Collection - List of Similar Values
..................................................................................

The field may have more values

 fieldName:[DataType]

  DataType here can be Scalar or Object type
 eg:
 fieldName:[String] | [Int] [Float]
 fieldName:[Address] [Order] [Items]

.....................................................................................
			 Query Type
.....................................................................................

Query is collection of apis
An api can return and accept values

No Parameter,Only Return
  field:Type

type Query {
 name:String  
 user:User
 users:[User]
}

Parameter,And Return Return
  field:Type

type Query {
  hello(name:String,message:String):String
  users:[User]
  userById(id:ID):[User]
}
...................................................................................
			    Advanced Types

=>Mutation 
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
  The Mutation is similar in Strcuture and purpose to the Query Type.

Where as Query is read only operations, where as "Mutation" is entry points for "Write and Read" operations

Signature of the Mutation:
.........................

type Mutation {
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
   updateUser(id:ID,user:User):User
   removeUser(id:ID):User
}
....................................................................................
			  Input Types
...................................................................................

Input types are special Object types that allow you to provide hierarchical data as arguments to fields( as apposed to providing only flat scalar arguments

type Mutation {
   #Flat scalar arguments
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
}

type Address {
  city:String!
  state:String!
  zipcode:String
}


type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

input UserInput { 
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

Mutation without inputType
type Mutation {
   #Flat scalar arguments
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
}
//Mutation with inputType
type Mutation {
   #Using Input Type
   createUser(userInput:UserInput):User
}
....................................................................................
				Enums
....................................................................................

An Enum is similar to scalar type, but its legal values are defined in the schema.

enum Gender {
 MALE
 FEMALE
 THIRD
}
How to use Enum?

type Query {
  gender:Gender
}
.....................................................................................
		  Union and Interfaces
...................................................................................

Unions and interfaces abstract GraphQL types that enables a schema field to return one of multiple object types.

union  Media= Image | Video

type Query {
 # This list can include both Image and Video Objects
 getMedia:[Media] 
}

Note:
  Union types must be only Object types not scalars or input types.
....................................................................................
			 Interface

Interface represents common fields that multiple objects can include.

interface Book {
 title:String!
 author:String!
}

type TechnicalBook implements Book {
 title:String!
 author:String!
 X:String
}

type StoryBook implments Book {
 title:String!
 author:String!
 Y:String
}

Query:
type Query {
  books:[Book]
}

Client Side: How to Query data Based on Interface

Syntax: 1 
query GetBooks{
  books {
   author
   title
  }
}

Here it returns all data ,

What if i want Technical and story book details with clear values

query GetBooks{

 books {
 
   __typename
   title
   ... on TechnicalBook {
      X
   }
   ... on StoryBook {
     Y
   }
 }
.....................................................................................	
.....................................................................................
			 Custom Scalar
.....................................................................................
GraphQL SDL provides basic core scalars - Int,String,Boolean,ID,Float.
What if i want other data types like Date,Time


How to define custom scalar

scalar  Date

type User {
 dob:Date
}

Here Date is custom Scalar, but how this data type is represented /logic of this type is provided through "Server side code"
.....................................................................................
				











