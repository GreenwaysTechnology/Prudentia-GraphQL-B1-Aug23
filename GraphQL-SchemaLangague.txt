.....................................................................................
	GraphQL - Server Side : GraphQL Schema language spec and implementation
...................................................................................

How to build rest applications?

 Restfull web services are built based on "resources" in the problem domain.

Resource represents a Object which expose data 


eg: CustomerResource,OrderResource,ProductResource
Resources are identified by URL /api/customers and Method "GET | POST | PUT |DELETE "
	
How to build graphql applications?
 
Graphql apps are built based on Objects called "Models".

What ever lanaugage we have to think in terms of Objects.

Object shape is described by "schema".

Schema is nothing but plan /design.

Schema represents the Object design

In Graphql The design is represented by "GraphQL schema Lanaguage"
.....................................................................................
			  SDL - Schema definition language
.....................................................................................

SDL Core concepts:

1.Type System:
   The Type system defines the Platform indenpendent data types and variable which describe what data can be queired by client.


query getUserData {
 
   user {
	name             =>SDL=>|SDL|===>Enity==>Biz logic(Services)====>DataSources
   }

}

Both Servers and clients talks via common language called SDL...

SDL provides language independant abstraction
				 
				|---- Java/Kotlin/scala --Jvm
			SDL-----|-----js/ts ----node



syntax:

type TypeName {
   field:DataType
}
In SDL , there is root type , every type is dervied from the root type

type schema{
  query:Query
  mutation:Mutation
  subscription:Subscription
}

type Query {
  #apis
}

type Mutation { 
 #apis
}

type Subscription{
 #apis
}

Query:
.....
Server side 

type Query {
  #apis
  greet:String
  user:User
  user(id:Int):User
}

Client Side
query {
 #api- sending request for invocation at server
  greet
}

query {
 #api
 user {
   id
   name
 }
}
query {
 #api
 user(id:1) {
   id
   name
 }
}
...
Server side
type Mutation { 
 #apis
 createUser(user:User):User
}

ClientSide:

mutation CreateUser($user:User){
  
   createUser(user:$user){
     id
     name
   }
}
SDL Defines schema language and platform independant data types:
.............................................................
1.Scallar types
2.Custom Types/ReferenceTypes/Object Types


1.Scallar Types:
  Scallars are like primitive types in your language

1.Int -32 bit signed integer
2.String - UTF-8 char Sequence
3.Boolean - true or false
4.Float - singed double 
5.ID (Serialized String)- A unique identifier

2.Object Type/Complex/User Defined/Reference Type
 Similar to classes in object oriented languages- like java,C#

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean  
}


Object Type can have other Object Type :
  Like has a relationship/ Dependency injection

type Address {
  city:String
  state:String
  zipcode:String
}

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:Address
}

type Query{ 
  user:User
}

Client side
query getUser{
  user {
   id
   firstName
   address {
     city
   } 
  }
}
....................................**********......................................
....................................................................................
			  Handling null and not null values
...................................................................................

Client Query With data
{
  name  --------> response {name:"subramanian"}
}

Client Query Without data
{
  name  --------> response {name:null}
}

I dont want null value for a given field? How to force the field must have data or must not have null?
 => not null fields

syntax:
 fieldName:Type!
!(not null)

type Address {
  city:String
  state:String
  zipcode:String
}

type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:Address
}
.....................................................................................
				...................................................................................
			  Collection - List of Similar Values
..................................................................................

The field may have more values

 fieldName:[DataType]

  DataType here can be Scalar or Object type
 eg:
 fieldName:[String] | [Int] [Float!]!
 fieldName:[Address] [Order] [Items]

.....................................................................................
			 Query Type
.....................................................................................

Query is collection of apis
An api can return and accept values

No Parameter,Only Return
  field:Type

type Query {
 name:String  
 user:User
 users:[User]
}

Parameter,And Return Return
  field:Type

type Query {
  hello(name:String,message:String):String
  users:[User]
  userById(id:ID):[User]
}
...................................................................................
			    Advanced Types

=>Mutation 
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
  The Mutation is similar in Strcuture and purpose to the Query Type.

Where as Query is read only operations, where as "Mutation" is entry points for "Write and Read" operations

Signature of the Mutation:
.........................

type Mutation {
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
   updateUser(id:ID,user:User):User
   removeUser(id:ID):User
}
....................................................................................
			  Input Types
...................................................................................

Input types are special Object types that allow you to provide hierarchical data as arguments to fields( as apposed to providing only flat scalar arguments)

type Mutation {
   #Flat scalar arguments
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
}

type Address {
  city:String!
  state:String!
  zipcode:String
}


type User{
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

input UserInput { 
  id:ID!
  firstName:String!
  lastName:String
  age:Int
  points:Float
  status:Boolean 
  address:[Address!]!
}

Mutation without inputType
type Mutation {
   #Flat scalar arguments
   createUser(id:ID,firstName:String,lastName:String,age:Int):User 
}
//Mutation with inputType
type Mutation {
   #Using Input Type
   createUser(userInput:UserInput):User
}
....................................................................................
				Enums
....................................................................................

An Enum is similar to scalar type, but its legal values are defined in the schema.

enum Gender {
 MALE
 FEMALE
 THIRD
}
How to use Enum?

type Query {
  gender:Gender
}
.....................................................................................
		  Union and Interfaces
...................................................................................

Unions and interfaces abstract GraphQL types that enables a schema field to return one of multiple object types.

union  Media= Image | Video

type Query {
 # This list can include both Image and Video Objects
 getMedia:[Media] 
}

Note:
  Union types must be only Object types not scalars or input types.
....................................................................................
			 Interface

Interface represents common fields that multiple objects can include.

interface Book {
 title:String!
 author:String!
}

type TechnicalBook implements Book {
 title:String!
 author:String!
 X:String
}

type StoryBook implments Book {
 title:String!
 author:String!
 Y:String
}

Query:
type Query {
  books:[Book]
}

Client Side: How to Query data Based on Interface

Syntax: 1 
query GetBooks{
  books {
   author
   title
  }
}

Here it returns all data ,

What if i want Technical and story book details with clear values

query GetBooks{

 books {
 
   __typename
   title
   ... on TechnicalBook {
      X
   }
   ... on StoryBook {
     Y
   }
 }
.....................................................................................	
.....................................................................................
			 Custom Scalar
.....................................................................................
GraphQL SDL provides basic core scalars - Int,String,Boolean,ID,Float.
What if i want other data types like Date,Time


How to define custom scalar

scalar  Date

type User {
 dob:Date
}

Here Date is custom Scalar, but how this data type is represented /logic of this type is provided through "Server side code"
.....................................................................................
				
.....................................................................................
				GraphQL Application Dev
.....................................................................................


Work Flow
1.SDL must be there and must be very clear.

GraphQL Application can be written in any language

Java:
1.graphql-java
2.SpringBoot with Graphql
3.DGS Framework - Netflix

Javascript:

1.graphql.js
   =>core framework written by facebook
   =>Express.js is underlaying framework

2.Apollo
    Apollo is platform for building enterprise graphql application.
    The core of Apollo is "graphql.js and Express.js"
 Graphql application can be built using two arch
 1.monolith arch
 2.Microservices arch.

Apollo Core concepts:
  SuperGraph:
      Collection of small graphs called subgraph
      A unified network of your organizations microservices and their datasources
      -All Composed into a single distributed API.

  SubGraph:
      It represents a single Graph application

  Graph OS:
     It is cloud platform which hosts supergraph and router

   Router :
      It is compostion api , clients will communicate only Router
     Router internally stiches the schema for data reterival.

Components of Apollo:
.....................
1.Apollo Server : node js server written in express.js
2.Schema defintions - SDL
3.Resolvers - Schema Implementations like queries,mutations,subscription
4.Data Sources -  Database,rest api, any other apis.

Apollo code can be written in "javascript or typescript".

Project Setup:
...............

1.create project folder
E:\session\Prudentia\B2>mkdir apollo-gettingstarted

2.create package.json
E:\session\Prudentia\B2\apollo-gettingstarted>npm init --yes
Wrote to E:\session\Prudentia\B2\apollo-gettingstarted\package.json:

{
  "name": "apollo-gettingstarted",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
3.launch code window
E:\session\Prudentia\B2\apollo-gettingstarted>code .
4.create source dir
E:\session\Prudentia\B2\apollo-gettingstarted>mkdir src

5.install dependencies
npm i @apollo/server graphql

Typescript dependency
npm i --save-dev typescript @types/node

package.json
  "dependencies": {
    "@apollo/server": "^4.9.1",
    "graphql": "^16.8.0"
  },
  "devDependencies": {
    "@types/node": "^20.5.3",
    "typescript": "^5.1.6"
  }

6.create ts config file
tsconfig.json
{
    "compilerOptions": {
        "rootDirs": [
            "src"
        ],
        "outDir": "dist",
        "lib": [
            "ES2020"
        ],
        "target": "ES2020",
        "module": "ESNext",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "types": [
            "node"
        ]
    },
}

package.json - scripts configuration
  "scripts": {
    "compile": "tsc",
    "start": "npm run compile && node ./dist/index.js"
  }

Write code inside src/index.ts
.....................................................................................

Programming steps:

1.define schema


//define schema
const typeDefs = `
type Query {
    hello:String
}
`
2.Biz logic : we need to write implementation for hello : Resolver
//define resolver
const resolvers = {
    //Query
    Query: {
        hello(): string {
            return "Hello,Apollo GraphQL"
        }
    }
    //Mutation

    //Subscription
}

3.we need to deploy(parse schema,bind resolvers)
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })


4.Start Web Container to run graphql app


//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})


Full code


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `
type Query {
    hello:String
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        hello(): string {
            return "Hello,Apollo GraphQL"
        }
    }
    //Mutation

    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Testing :

http://localhost:4000/

query HelloQuery {
  hello
}

response:
  "data": {
    "hello": "Hello,Apollo GraphQL"
  }
}
.....................................................................................
			 Descriptions(docStrings
.....................................................................................
Graphql schema defintion supports markdown enabled documentation strings called "descriptions"
This helps consumers of your graph discover fields and learn how to use them.

""comments"" => single line comment
""" =>multi line comments

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `
type Query {
    """
        This is hello api which returns Hello,Apollo GraphQL
    """
    hello:String
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        hello(): string {
            return "Hello,Apollo GraphQL"
        }
    }
    //Mutation

    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)
.....................................................................................
			  Default Resolver
.....................................................................................
I have schema which has apis should i provide implementation every time?
 No need,
if you define query, if you dont define resolver,The Apollo provides default resolver which returns "null" always

Eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `
type Query {
    """
        This is hello api which returns Hello,Apollo GraphQL
    """
    hello:String
}
`

//define resolver
const resolvers = {
    //Query
    Query: {

    }
    //Mutation
    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Client:
query HelloQuery {
  hello
}
{
  "data": {
    "hello": null
  }
}
....................................................................................
			Multiple apis

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `
type Query {
    """
        This is hello api which returns Hello,Apollo GraphQL
    """
    hello:String
    greet:String
    hai:String
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        hello() {
            return "Hello"
        },
        hai() {
            return "Hai"
        },
        greet() {
            return "Greet"
        }

    }
    //Mutation
    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)
		.....................................................................................
			Object Type and Queries
.....................................................................................

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `

type User {
 id:ID
 firstName:String
 lastName:String
 age:Int
 points:Float
 status:Boolean
}

type Query {
  user:User
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        user() {
            return {
                id: 1,
                firstName: "Subramanian",
                lastName: "Murugan",
                age: 10,
                points: 10,
                status: true
            }
        }

    }
    //Mutation
    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)


Client:
query User {
  user {
    id
    firstName
    lastName
  }
}

{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "lastName": "Murugan"
    }
  }
}
.....................................................................................
			 Collections
....................................................................................
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `
type User {
 id:ID
 firstName:String
 lastName:String
 age:Int
 points:Float
 status:Boolean
}

type Query {
  user:User
  users:[User]
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        user() {
            return {
                id: 1,
                firstName: "Subramanian",
                lastName: "Murugan",
                age: 10,
                points: 10,
                status: true
            }
        },
        users() {
            return [
                {
                    id: 1,
                    firstName: "Subramanian",
                    lastName: "Murugan",
                    age: 10,
                    points: 10,
                    status: true
                },
                {
                    id: 2,
                    firstName: "Geetha",
                    lastName: "Subramanian",
                    age: 10,
                    points: 34,
                    status: true
                },
                {
                    id: 3,
                    firstName: "Shirisha",
                    lastName: "Subramanian",
                    age: 10,
                    points: 800,
                    status: true
                }
            ]
        }

    }
    //Mutation
    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)


Client side:
query User {
  users {
    id
    firstName
    lastName
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "firstName": "Subramanian",
        "lastName": "Murugan"
      },
      {
        "id": "2",
        "firstName": "Geetha",
        "lastName": "Subramanian"
      },
      {
        "id": "3",
        "firstName": "Shirisha",
        "lastName": "Subramanian"
      }
    ]
  }
}
....................................................................................
			  Handle Args and Params
....................................................................................
How to handle args and parameters?
  A resolver function takes four postional args optional args

Syntax:
  function resolver(parent,args,contextValue,info){

  } 
 
args which is variable going to hold parametes passed by clients
args value is going to be literal object
If you pass more no of parameters, all parameters are passed  and stored into one single object.


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `
type Query {
    hello(name:String):String
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        hello(parent, args, contextValue, info): string {
            return `Hello ${args.name}`
        }
    }

}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Client:
Static Parameter
query getHello {
  hello(name: "Subramanian")
}
{
  "data": {
    "hello": "Hello Subramanian"
  }
}
Dynamic Parameter:
..................
query getHello($name:String) {
  hello(name: $name)
}

variable:
{
  "name": "Murugan"
}
response:
{
  "data": {
    "hello": "Hello Murugan"
  }
}
....................................................................................
Use Case:

 I have collection called users.
 write api to filter data based on UserId
.....................................................................................
			Nested Type
.....................................................................................

User has Address

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `

type Address {
  city:String
}

type User {
 id:ID
 firstName:String
 lastName:String
 age:Int
 points:Float
 address:Address
 status:Boolean
}

type Query {
  user:User
  users:[User]
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        user() {
            return {
                id: 1,
                firstName: "Subramanian",
                lastName: "Murugan",
                age: 10,
                points: 10,
                address: {
                    city: 'Coimbatore'
                },
                status: true
            }
        }

    }
    //Mutation
    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Client:
query User {
  user {
    id
    address {
      city
    }
  }
}
{
  "data": {
    "user": {
      "id": "1",
      "address": {
        "city": "Coimbatore"
      }
    }
  }
}
....................................................................................
			How to coimbine multiple datasets and query?

I have users Array
I have address Array

I have to connect users with address.


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//mock data:
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}
]
const ADDRESS = [{
    city: 'CBE',
    state: 'TN',
    id: 1, //linking field  looks like foreign key
},
{
    city: 'BNG',
    state: 'KA',
    id: 2, //linking field  looks like foreign key
},
{
    city: 'HYD',
    state: 'TS',
    id: 1, //linking field  looks like foreign key
}
]




//define schema
const typeDefs = `

type Address {
  city:String
}

type User {
 id:ID
 name:String
 email:String
 address:Address
}

type Query {
  users:[User]
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        }
    }
    //Mutation
    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Client side:
query Users {
  users {
    id
    name
    email
    address {
      city
    }
  }
}

{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": null
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": null
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": null
      }
    ]
  }
}

Here we get null value in the address, because the data set is not linked .
....................................................................................
			  Resolver Chains
....................................................................................
Resolver chain means coimbin results of one resolver with in nested resolver.


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//mock data:
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}
]
const ADDRESS = [{
    city: 'CBE',
    state: 'TN',
    id: 1, //linking field  looks like foreign key
},
{
    city: 'BNG',
    state: 'KA',
    id: 2, //linking field  looks like foreign key
},
{
    city: 'HYD',
    state: 'TS',
    id: 3, //linking field  looks like foreign key
}
]

//define schema
const typeDefs = `
type Address {
  city:String
}

type User {
 id:ID
 name:String
 email:String
 address:Address
}

type Query {
  users:[User]
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        }
    },
    //Resolver Chain
    User: {
        address(parent, args, contextValue, info) {
            console.log(parent)
            return ADDRESS.find(address => {
                return address.id === parent.id
            })
        }
    }
    //Mutation
    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

query Users {
  users {
    id
    name
    email
    address {
      city
    }
  }
}
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": {
          "city": "CBE"
        }
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": {
          "city": "BNG"
        }
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": {
          "city": "HYD"
        }
      }
    ]
  }
}
....................................................................................
			  Cardinality Relationship
....................................................................................

Many to Many : Many users. Each User can have Many address


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//mock data:
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}
]
const ADDRESS = [{
    city: 'CBE',
    state: 'TN',
    id: 1, //linking field  looks like foreign key
},
{
    city: 'BNG',
    state: 'KA',
    id: 1, //linking field  looks like foreign key
},
{
    city: 'BNG',
    state: 'KA',
    id: 2, //linking field  looks like foreign key
},
{
    city: 'CBE',
    state: 'TN',
    id: 2, //linking field  looks like foreign key
},
{
    city: 'HYD',
    state: 'TS',
    id: 3, //linking field  looks like foreign key
},
{
    city: 'DEL',
    state: 'HR',
    id: 3, //linking field  looks like foreign key
}
]

//define schema
const typeDefs = `
type Address {
  city:String
}

type User {
 id:ID
 name:String
 email:String
 address:[Address]
}

type Query {
  users:[User]
}
`

//define resolver
const resolvers = {
    //Query
    Query: {
        users() {
            return USERS
        }
    },
    //Resolver Chain
    User: {
        address(parent, args, contextValue, info) {
            console.log(parent)
            return ADDRESS.filter(address => {
                return address.id === parent.id
            })
        }
    }
    //Mutation
    //Subscription
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Client:
query Users {
  users {
    id
    name
    email
    address {
      city      
    }
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": [
          {
            "city": "CBE"
          },
          {
            "city": "BNG"
          }
        ]
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": [
          {
            "city": "BNG"
          },
          {
            "city": "CBE"
          }
        ]
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": [
          {
            "city": "HYD"
          },
          {
            "city": "DEL"
          }
        ]
      }
    ]
  }
}
.....................................................................................
Lab:
  One to Many with single User- Parametermized.

.....................................................................................
			 Mutations
.....................................................................................

How to send data for insert , update,remove.

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//mock data:
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}
]

//define schema
const typeDefs = `

type User {
 id:ID
 name:String
 email:String
}

type Query {
  users:[User]
}

input CreateUserInput{
  id:ID
  name:String
  email:String
}

type Mutation{
    createUser(userInput:CreateUserInput):User
}

`

//define resolver
const resolvers = {
    Query: {
        users() {
            return USERS;
        }
    },
    Mutation: {
        createUser(_, args) {
            USERS.push(args.userInput)
            return args.userInput
        }
    }

}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Client Side:

mutation CreateUser($userInput: CreateUserInput) {
  createUser(userInput: $userInput) {
    id
    name
    email
  }
}

{
  "userInput":{
    "id":4,
    "name":"Subramaian",
    "email":"subu@gmail.com"
  }
}

After adding , Test in another window

query Users {
  users {
    email
    id
    name
  }
}

{
  "data": {
    "users": [
      {
        "email": "a@gmail.com",
        "id": "1",
        "name": "A"
      },
      {
        "email": "b@gmail.com",
        "id": "2",
        "name": "B"
      },
      {
        "email": "c@gmail.com",
        "id": "3",
        "name": "C"
      },
      {
        "email": "subu@gmail.com",
        "id": "4",
        "name": "Subramaian"
      },
]
....................................................................................
				Null and Not Null
....................................................................................
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `

type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
}
type Query {
    user:User! #This api must return data and must not return null
}

`

//define resolver
const resolvers = {
    Query: {
        user() {
            return {
                id: 1,
                firstName: "Subramanian",
                lastName: "Murugan",
                age: 10,
                points: 10,
                status: true
            }
        }
    }
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

In the above code

The schema defines rule that user's api return type must not be null.

type Query {
    user:User! #This api must return data and must not return null
}

In the resolver if you return null 
  Query: {
        user() {
                  return null;
        }
    }

Client Side:
query User {
  user {
    firstName
    id
    lastName
    points
    status
    age
  }
}

Response
{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.user.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "user"
      ]
]
...................................................................................
				What if fields are not null
...................................................................................

Type:
type User {
    id:ID!
    firstName:String!
    lastName:String
    age:Int
    points:Float
    status:Boolean
}

In the Resolver:

    Query: {
        user() {
            return {
                id: null,
                firstName: null,
                lastName: "Murugan",
                age: 10,
                points: 10,
                status: true
            }
        }
    }

if you dont define fields or field value is null, the server will throw error.


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `

type User {
    id:ID!
    firstName:String!
    lastName:String
    age:Int
    points:Float
    status:Boolean
}
type Query {
    user:User! #This api must return data and must not return null
}

`

//define resolver
const resolvers = {
    Query: {
        user() {
            return {
                id: null,
                firstName: null,
                lastName: "Murugan",
                age: 10,
                points: 10,
                status: true
            }
        }
    }
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)
....................................................................................
			  Collections and Null
....................................................................................

Syntax:
 products:[Product!]
 products:[Product]!
 products:[Product!]!

products:[Product!]

products:null - valid - array is null
products:[] -  valid
products:[{id:1}] -valid
products:[null] -invalid - throws exception.
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `

type Query {
    skills:[String!]
}
`

//define resolver
const resolvers = {
    Query: {
        skills() {
            //return ["js"]
            //return []
            //return null
            return [null]
        }
    }
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Client:
query Query {
  skills
}
Response:
{
  "data": {
    "skills": null
  },
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.skills.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
}
...................................................................................

skills:[String]!


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `

type Query {
    skills:[String]!
}
`

//define resolver
const resolvers = {
    Query: {
        skills() {
            // return ["js"]
            //return []
            return null
             //return [null]
        }
    }
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Client:
query Query {
  skills
}
Response:
{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.skills.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
....................................................................................

skills:[String!]!
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `

type Query {
    skills:[String!]!
}
`

//define resolver
const resolvers = {
    Query: {
        skills() {
            // return ["js"]
            //return []
            //return null
            return [null]
        }
    }
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)

Client:

query Query {
  skills
}

Response:
{
  "data": {},
  "errors": [
    {
      "message": "Cannot return null for non-nullable field Query.skills.",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
....................................................................................
			 Handling Not null in args
................................................................................
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `

type Query {
    hello(name:String!):String!
}
`

//define resolver
const resolvers = {
    Query: {
        hello(_, args) {
            return `Hello ${args.name}`
        }
    }
}

//deployment : parsing ,binding
const server = new ApolloServer({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is ready ${url}`)



Client:
query Query($name: String!) {
  hello(name: $name)
}
Variable
{
  "name": null
}
Response:
{
  "data": {},
  "errors": [
    {
      "message": "Variable \"$name\" of non-null type \"String!\" must not be null.",
      "locations": [
        {
          "line": 1,
          "column": 13
        }
      ]
}
...................................................................................
			 Context and ContextValue
....................................................................................


Context is Object - can be used to share information across application.
Context can hold global variables like database connection,authKey....

Context values can be accessed inside resolver, plugins,__resolverType with convention name called "contextValue".


context function:
 It is function which is part of "ApolloServer".

context object can be typed, since we are using typescript we can have strong typing behaviour.

How to declare context Object?

interface MyContext {
    companyName:String
}

const server = new ApolloServer<MyContext>({ typeDefs: typeDefs, resolvers: resolvers })


const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context:: async()=>{
	return {
	  companyName:'google'
	}
    }
})
How to access context variables?

Query: { 
       hello(parent, args,contextValue,info) {
            return `Hello ${args.name}`
        }
}

eg:
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//define Context type:For type Script
interface MyContext {
    message: String
}

//define schema
const typeDefs = `

type Query {
    hello(name:String!):String!
}
`

//define resolver
const resolvers = {
    Query: {
        hello(_, args, contextValue) {
            return `${contextValue.message} ${args.name}`
        }
    }
}

//deployment : parsing ,binding
const server = new ApolloServer<MyContext>({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async ({ req, res }) => {
        return {
            message: 'Hello'
        }
    }
})
console.log(`Apollo Server is ready ${url}`)

Client:
query Query($name: String!) {
  hello(name: $name)
}
Variables
{
  "name": "Subramanian"
}
Response:
{
  "data": {
    "hello": "Hello Subramanian"
  }
}
.....................................................................................
			 Data Sources & Context
....................................................................................


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//define schema
const typeDefs = `
type Book {
  title:String
  author:String
}

type Query {
    books:[Book]
}
`
const Books = [{
    title: 'GraphQl in Action',
    author: 'A',

},
{
    title: 'Apollo in Action',
    author: 'B',

},
{
    title: 'Typescript in Action',
    author: 'C',

}

]

// datasource class
export class BookDataSource {
    //api 
    getBooks() {
        return Books
    }
    //getBooksById

    //save

    //update

    //remove

}

//define Context type:For type Script


//define resolver
const resolvers = {
    Query: {
        // books(parent, args, contextValue) {
        //     return contextValue.dataSources.booksAPI.getBooks()
        // }
        books(parent, args, contextValue) {
            const { dataSources: { booksAPI: { getBooks } } } = contextValue
            return getBooks()
        }
    }
}

interface MyContext {
    dataSources: {
        booksAPI: BookDataSource
    }
}
//deployment : parsing ,binding
const server = new ApolloServer<MyContext>({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async ({ req, res }) => {
        return {
            dataSources: {
                booksAPI: new BookDataSource()
            }
        }
    }
})
console.log(`Apollo Server is ready ${url}`)


Client:
query Books {
  books {
    author
    title
  }
}

Response:
{
  "data": {
    "books": [
      {
        "author": "A",
        "title": "GraphQl in Action"
      },
      {
        "author": "B",
        "title": "Apollo in Action"
      },
      {
        "author": "C",
        "title": "Typescript in Action"
      }
    ]
  }
}
.....................................................................................
			 External DataSources,Context
.....................................................................................

Data Sources:
1.Rest
2.Database

REST As Back End:

Steps:

1.Setup local Rest api

E:\session\Prudentia>mkdir myapiserver

E:\session\Prudentia>cd myapiserver

E:\session\Prudentia\myapiserver>npm install -g json-server

............

2.create db.json file the project dir
{
    "books": [
        {
            "title": "GraphQl in Action",
            "author": "A"
        },
        {
            "title": "Apollo in Action",
            "author": "B"
        },
        {
            "title": "Typescript in Action",
            "author": "C"
        }
    ]
}
3.Start Rest api server
E:\session\Prudentia\myapiserver>json-server --watch db.json
.....................................................................................
Graphql Setup:
..............

Steps:
 
1.Create Service/API class in order to communicate REST api.
 Apollo Provides a special wrapper class to connect to rest apis.

npm install @apollo/datasource-rest --save

2.Declare Your own class and extends "RESTDataSource" superclass

3.Write typedef, resolver

eg:
import { RESTDataSource } from "@apollo/datasource-rest";
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//Type class
export class Book {
    title: string
    author: string
}
//Data Source class
export class BooksAPI extends RESTDataSource {
    constructor() {
        super()
        //base url
        this.baseURL = "http://localhost:3000/"
    }
    //apis 
    async getBooks() {
        return this.get<Book[]>(`books`)
    }
    //post

    //update

    //delete
}

//define schema
const typeDefs = `
type Book {
  title:String
  author:String
}

type Query {
    books:[Book]
}
`

//define resolver
const resolvers = {
    Query: {
        async books(parent, args, contextValue) {
            return contextValue.dataSources.booksAPI.getBooks()
        }
    }
}
interface MyContext {
    dataSources: {
        booksAPI: BooksAPI
    }
}
//deployment : parsing ,binding
const server = new ApolloServer<MyContext>({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async ({ req, res }) => {
        return {
            dataSources: {
                booksAPI: new BooksAPI()
            }
        }
    }
})
console.log(`Apollo Server is ready ${url}`)

Client:
query Books {
  books {
    title
    author
  }
}
{
  "data": {
    "books": [
      {
        "title": "GraphQl in Action",
        "author": "A"
      },
      {
        "title": "Apollo in Action",
        "author": "B"
      },
      {
        "title": "Rest in Action",
        "author": "C"
      },
      {
        "title": "Typescript in Action",
        "author": "D"
      }
    ]
  }
}
.....................................................................................
			 Mutation : Post and Update
....................................................................................

import { RESTDataSource } from "@apollo/datasource-rest";
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'


//Type class
export class Book {
    id?: number
    title?: string
    author?: string
}
export class MutationResponse {
    status: string
    data?: string
}

//Data Source class
export class BooksAPI extends RESTDataSource {
    constructor() {
        super()
        //base url
        this.baseURL = "http://localhost:3000/"
    }
    //apis 
    async getBooks() {
        return this.get<Book[]>(`books`)
    }
    async book(id: number) {
        return this.get<Book>(`books/${id}`)
    }
    //post
    async postBook(book: Book) {
        return this.post<Book>(`books`, { body: book }).then(res => res)
    }
    //update
    async updateBook(bookId: number, book: Book) {
        return this.put<Book>(`books/${bookId}`, { body: book }).then(res => res)
    }
    //delete

}

//define schema
const typeDefs = `
type Book {
  id:Int
  title:String
  author:String
}

type Query {
    books:[Book!]!
    book(id:Int!):Book
}
input BookInput{
    id:Int!
    title:String!
    author:String!
}
input BookUpdateInput {
    title:String!
    author:String!
}

type Mutation{ 
    addBook(input:BookInput):Book
    updateBook(id:Int!,input:BookUpdateInput):Book
}
`

//define resolver
const resolvers = {
    Query: {
        async books(parent, args, contextValue) {
            return contextValue.dataSources.booksAPI.getBooks()
        },
        async book(parent, args, contextValue) {
            const { dataSources } = contextValue;
            const id = +args.id
            return dataSources.booksAPI.book(id)
        }
    },
    Mutation: {
        async addBook(parent, args, contextValue, info) {
            const { input } = args
            const { dataSources } = contextValue
            return dataSources.booksAPI.postBook(input)
        },
        async updateBook(parent, args, contextValue, info) {
            const { input, id } = args
            const { dataSources } = contextValue
            return dataSources.booksAPI.updateBook(id, input)
        }
    }
}
interface MyContext {
    dataSources: {
        booksAPI: BooksAPI
    }
}
//deployment : parsing ,binding
const server = new ApolloServer<MyContext>({ typeDefs: typeDefs, resolvers: resolvers })

//start web container
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    },
    context: async ({ req, res }) => {
        return {
            dataSources: {
                booksAPI: new BooksAPI()
            }
        }
    }
})
console.log(`Apollo Server is ready ${url}`)


Changes in db.json
{
    "books": [
        {
            "id": 1,
            "title": "GraphQl in Action",
            "author": "A"
        },
        {
            "id": 2,
            "title": "Apollo in Action",
            "author": "B"
        },
        {
            "id": 3,
            "title": "Rest in Action",
            "author": "C"
        },
        {
            "id": 4,
            "title": "Typescript in Action",
            "author": "D"
        }
    ]
}

Client:

Get All books:

query Books {
  books {
    author
    id
    title
  }
}

GetBooksById
query Books($bookId: Int!) {
  book(id: $bookId) {
      id
      title
      author
  }
}

Save:
mutation SaveBook($input:BookInput) {
   addBook(input:$input) {
     author
     id
     
   }
}
variables:
{
  "input": {
    "id": 100,
    "title": "Graphql with rest",
    "author": "Subramanian"
  }
}

Update:
mutation UpdateBook($updateBookId: Int!, $input: BookUpdateInput) {
  updateBook(id: $updateBookId, input: $input) {
    title
  }
}
Variables
{
  "updateBookId": 4,
  "input" : {
    "title": "Graphql with db",
    "author": "Subramanian"
  }
}


